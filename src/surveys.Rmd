---
title: "Analysing survey data"
author: "Paul Sharpe, Sophie Homer, Andy Wills"
output: html_document
---

```{r setup, include=FALSE}
## DEVELOPERS: Uncomment one option, as appropriate

## Show only commands.
## knitr::opts_chunk$set(echo = TRUE, message = FALSE, results='hide', fig.keep = 'none', comment=NA)

## Show commands and output.
knitr::opts_chunk$set(echo = TRUE, comment=NA, cache = TRUE)
options(tibble.width = Inf) # show all columns in output
```

# Contents

- [Introduction](#intro)

- [Getting started](#start)

- [Preprocessing](#preprocessing)

- [Reverse scoring survey items](#reverse)

- [Calculating survey scores](#score)

- [Calculating Cronbach’s alpha](#cronbach)

- [Comparing baseline scores between conditions (one-way ANOVA)](#baseline)

- [Comparing scores before and after an intervention (within-between ANOVA)](#prepost)

<a name="intro"></a>

# Before you start...

This worksheet assumes familiarity with the techniques described in the following worksheets:

* [Preprocessing data from experiments](preproc.html)
* [Within-subject differences](anova1.html)
* [Factorial differences](anova3.html).

If the techniques in this worksheet seem challenging, return here after reviewing the material in these worksheets.

# Introduction

A wide range of psychological constructs are measured using surveys. A survey is a set of questions designed to measure a specific construct, for example self-esteem. Answers to survey questions are often Likert scales. These allow a participant to express how much they agree or disagree with a particular statement e.g. `0=Not at all, 1=A little, 2=Somewhat, 3=A lot, 4=Extremely`. A formula is applied to a participant's scores to calculate an overall number which measures their score for the construct, e.g. their level of self-esteem.

To ensure that a scale is valid and relible, the questions are often developed using a method called factor analysis. A scale is valid if it is a true measure of the construct, in this example it accurately reflects levels of self-esteem, rather than something else. A scale is reliable if it gives consistent results, i.e. a person who completed the scale at different times would produce similar scores, as would two people who are similar in terms of the construct.

In this worksheet, we'll cover some common techniques which you are likely to use when processing survey data. We'll be using real data from two different surveys. The Depression Anxiety Stress Scales—21 (DASS-21, Heatherton & Polivy, 1991) is a 21-item scale for measuring depression, anxiety and stress. The State Self-Esteem Scale (SSES, Osman et al., 2012) is a 20-item survey used to measure short-lived (state) changes in self-esteem.

<a name="start"></a>

# Getting started

Create a new R project and upload the files `dass21.csv` and `state-self-esteem.sav`, which you will find in the git repository we used [previously](preproc.html#load).

FIXME <span style="color: red;">Add data sets to rminr-data</span>

```{r init-load, message=FALSE}
rm(list = ls()) # clear the environment
library(tidyverse)
```

<a name="preprocessing"></a>

# Preprocessing

Survey data can be collected using [JISC](https://www.jisc.ac.uk/), [Gorilla Survey](https://gorilla.sc/), [OpenSesame](https://osdoc.cogsci.nl/), [The Experiment Factory](https://expfactory.github.io/experiments/), [Qualtrics](https://www.qualtrics.com/) and many other software packages. Most software will allow you to save your data as a CSV file. The precise structure of the data varies between packages, so you are likely to have to start by [preprocessing](preproc.html) your data. The preprocessing tasks described in this worksheet should be useful regardless of the software you used to collect your survey data, although they might need slight modifications depending on the data you start with.

## Loading data

We'll start by preprocessing the DASS-21 data, which is a wide format (one row per participant) CSV file.

```{r pre-process-dass}
dass21_raw <- read_csv("dass21.csv") %>%
  select(partID, Age:DASS21)
```

**Explanation of command:**

We read the CSV file using `read.csv` and pipe the data into a function to `select()`, just the columns we want, saving the results in `dass21_raw`.

The first column we `select()`, is the participant ID, which is stored in the `partID` column. Arguments to `select()` can also be consecutive ranges of columns in a data frame, consisting of the first and last column (left to right) name, separated by a `:`. This avoids having to type out long lists of column names.  Here we use `Age:DASS21` to select all columns between `Age` and `DASS21`.

## Handling missing data

If participants don't complete a survey, you will want to exclude their data from your analyses. If we look at a section of the DASS-21 data, we can see some that data is missing for some participats.

```{r missing, echo=FALSE}
library(kableExtra)
slice(dass21_raw, 73:76) %>%
  kable("html") %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%")
```

The first thing to notice is that our data frame contains only the columns that we selected in the commands above.

Participants `108`, and `109` (rows 3 and 4) have numbers in all columns, indicating that their data is complete. However, participants `106` and `107` have cells containing the value `NA`, which means these cells in the CSV file were empty. For participant `106`, all cells are `NA` (perhaps they dropped out of the study), and for participant `107`, all of the DASS-21 cells are `NA` (perhaps they skipped this survey).

We can exclude any rows with missing data as follows:

```{r exclude-missing}
dass21 <- dass21_raw %>% drop_na()
```

**Explanation of command:**

We pipe the raw data into the `drop_na()` function (part of the `tidyverse` package). This drops any rows with a column containing `NA`. This code would also exclude participants who completed only part of a survey.

## Tidying a data frame

Removing columns which aren't required in your analysis is the first step in most preprocssing. We'll demonstrate some techniques which are especially useful for preprocessing survey data using the SSES dataset.

We start by loading the data:

```{r read-sses}
library(foreign)
sses <- read.spss('state-self-esteem.sav', to.data.frame=TRUE)
```

**Explanation of commands:**

The `.sav` file extension indicates that the SSES data was saved from SPSS. The `foreign` package allows R to read SPSS files into a data frame. We load the package, and then use `read.spss()` to read the data and store it in `sses`.
 
This data comes from from an experiment in which self-esteem was measured before and after participants completed one of two mental imagery conditions, or a control condition. For our analyses it will be useful to divide the data into two data frames, one for the pre-intervention SSES, the other for the post-intervention SSES. We can do that in a single pipeline.

```{r preprocess-sses-pre}
sses_pre_raw  <- sses %>% select(1, 5:25) %>%
  set_names(~ str_to_lower(.) %>% str_replace_all("pre_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('pre')) %>%
  select(subj, condition, time, q1:q20)
```

**Explanation of pipeline commands:**

`sses_pre_raw  <- sses %>% select(1, 5:25)` - We save the output of the pipeline in `sses_pre_raw`. The first step pipes the full dataset, `sses` into a `select` which keeps column 1, and columns 5:25. Column 1 is the participant id, columns 5:24 are the SSES scores, and column 25 is the participant's condition.

`set_names(~ str_to_lower(.) %>% str_replace_all("pre_sse_", "q"))` - Next, we use `set_names()` to rename our columns. The `~` is a way of telling `set_names()` to apply a function to the column name. The remainder of the command is the function itself. This is a mini-pipeline which tidies up the column name. The command `str_to_lower(.)` makes the column name lowercase. The command `str_replace_all("pre_sse_", "q"))` replaces columns with the prefix `pre_sse_` with the prefix `q`. All our columns are now lowercase, and the SSES questions are named `q1:q20`.

`mutate(subj = factor(partid), condition = factor(condition), time = factor('pre'))` - Next, we use `mutate` to add and modify some columns. The argument `subj = factor(partid)` creates a new column named `subj` (which is a bit clearer than `partid`) by copying the `partid` column and making it a factor. The argument `condition = factor(condition)` makes the `condition` column a factor. The argument `time = factor('pre')` creates a new factor called `time` and sets all values to `pre`.

`select(subj, condition, time, q1:q20)` - Finally, we use `select()` to put the columns into a convenient order for viewing.

## Recode factor levels

Software for running experiments may use numbers to represent different levels of a factor. It's often clearer if these are converted to strings which describe the factor. In this experiment, participants in condition 1 visualised a negative mental image of themself, participants in condition 2 visualised a negative mental image of someone else, and condition 0 was a control condition, in which participants did a card sorting task and did not think of any images.

```{r}
sses_pre_raw$condition <- recode_factor(sses_pre_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

```

**Explanation of command:**

We use `recode_factor()` to rename the levels of the experimental condition (`sses_pre_raw$condition`). The current factor level name goes on the left hand side of the `=`, the new name goes on the right hand side. Notice that the numbers need to be in backticks. The renamed factor levels are reassigned to the same column `sses_pre_raw$condition`.

Our data frame now has intuitive column and factor names:

```{r, R.options = list(width = 100)}
sses_pre_raw %>% head(3)
```

We use a similar pipeline to create a tidy data frame (`sses_post_raw`) containing the post-intervention SSES data.

```{r preprocess-sses-post}
sses_post_raw <- sses %>% select(1, 25:45) %>%
  set_names(~ str_to_lower(.) %>% str_replace_all("post_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('post')) %>%
  select(subj, condition, time, q1:q20)
sses_post_raw$condition <- recode_factor(sses_post_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

```

**Explanation of command:**

This is indentical to the previous pipeline, except that the post-intervention SSES data are in columns `26:45`, these columns have the prefix `post_sse_` rather than `pre_sse_`, and we use the value `post` in our `time` factor.

```{r, R.options = list(width = 100)}
sses_post_raw %>% head(3)
```

<a name="reverse"></a>

# Reverse score survey

The SSES consists of 20 questions, each of which is scored from `0 (Not at all)` to `4 (Extremely)`. Question 1 reads `I feel confident about my abilities`, so a higher score indicates higher self-esteem. A number of questions on the SSES are 'reverse scored'. For example, question 2 reads `I am worried about whether I am regarded as a success or failure`, so in this case a higher score indcates lower self-esteem. Surveys often use reverse scored questions to encourage participants to pay attention to the wording of each question.  

Before totalling the SSES, we need to reverse the reverse scored items, so that a higher number means higher self-esteem for all scores. We have a number of reverse scored items which we need to reverse for each participant. It would be laborious to write code to do this for each one, so we'll create a function to reverse any reverse coded score.

At this point you will be familiar with _using_ functions like `rm()` which are part of `R`, and functions like `read.csv()`, and `select()` which are provided by packages which you load using `library()` (another base `R` function). Using `function()` (yet another base `R` function!), we can define our own functions for tasks we want to do repeatedly. In this case we want a function to reverse reverse coded survey items.

```{r reverse-score-survey}
# Reverse score survey items
# @param scores raw scores data frame
# @param reverse character vector of columns to be reverse scored
# @param max integer value of maximum score
reverse_score_survey <- function(scores, reverse, max) {
  reverse_score <- function(score) { max - score } # for scores starting at 1, max + 1 - score
  scores %>% mutate_at(reverse, reverse_score)
}
```

**Explanation of commands:**

The result of the `function()` function, is our custom function code. We assign this to the variable `reverse_score_survey`. Our `reverse_score_survey()` function requires three arguments: `scores` is a data frame containing raw survey responses, i.e. with some items reverse scored, `reverse` is a character vector containing the column names of the scores that are reverse scored, and `max` is the maximum score available for an item on the Likert scale.

Inside this function, we define another function called `reverse_score` which takes a `score` argument, and reverses it using the calculation `max - score`. For example, `reverse_score(4)`, would return the value `0` (`4 - 4`).  If your survey scores began at 1, you could adjust the calculation to `max + 1 - score`.

The final line in `reverse_score_survey` pipes our raw scores into `mutate_at(reverse, reverse_score)`. The `mutate_at()` function applies a function to a subset of columns in a data frame. The first argument `reverse` is the list of column names to be reversed. The second argument `reverse_score` is the name of the function we wrote to reverse the score.

When we call `reverse_score_survey`, the result will be a data frame with all scores adjusted to be from 0 to `max`.

Having created our `reverse_score_survey` function, we can call it to reverse score our pre and post intervention SSES scores:

```{r reverse-pre}
reverse_questions <- c('q2', 'q4', 'q5', 'q7', 'q8', 'q10', 'q13', 'q15', 'q16', 'q17', 'q18',
                       'q19', 'q20')
sses_pre  <- reverse_score_survey(sses_pre_raw, reverse_questions, 4)
sses_post <- reverse_score_survey(sses_post_raw, reverse_questions, 4)
```

**Explanation of commands:**

We set `reverse_questions` to be a vector of the column names of the SSES items that are reverse scored.

Next we call the function `reverse_score_survey(sses_pre_raw, reverse_questions, 4)`. When the function is run, `sses_pre_raw` is assigned to the `scores` argument, `reverse_questions` to the `reverse` argument, and `4` to the `max` argument. The resulting data frame (higher score meaning higher self-esteem for all items) is assigned to `sses_pre`. We call the function with `sses_post_raw` to reverse score the post-intervention surveys and assign the result to `sses_post`.

Notice that we could call this function with different arguments to reverse the reverse coded items on any survey in which questions are answered using a Likert scale.

<a name="score"></a>

# Calculate a total score for pre and post

Our data is now in a format which makes it easy to calculate the SSES baseline scores:

```{r pre-score, R.options = list(width = 100)}
sses_pre <- mutate(sses_pre, total = rowSums(sses_pre[4:23]))
sses_pre %>% head(3)
sses_pre %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))
```

**Explanation of commands:**

First we use `mutate()` to create a `total` column for each row using `rowSums(sses_pre[4:23])` to add up the individual scores for each participant. We reassign the resulting data frame back to `sses_pre` effectively adding a `total` score column.

We then `group_by(condition)` to generate a mean and standard deviation for each condition.

We do the same for post-intervention scores:

```{r post-score}
sses_post <- mutate(sses_post, total = rowSums(sses_post[4:23]))
sses_post %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))
```

## Calculate subscale scores

In addition to a total score, some surveys include subscales which measure more specific aspects of a construct. These can be calculated by adding together scores from specific items. For example, the DASS-21 has depression, anxiety and stress subscales. We can use `rowSums()` to add together the scores for items which make up these subscales:

```{r dass21-subscales}
dass21 <- mutate(dass21, depression = rowSums(dass21[c(4+3,4+5,4+10,4+13,4+16,4+17,4+21)]))
dass21 <- mutate(dass21, anxiety = rowSums(dass21[c(4+2,4+4,4+7,4+9,4+15,4+19,4+20)]))
dass21 <- mutate(dass21, stress = rowSums(dass21[c(4+1,4+6,4+8,4+11,4+12,4+14,4+18)]))
```

```{r, echo=FALSE}
dass21 %>%
  head() %>%
  select(DASS1:stress) %>%
  kable("html") %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%")
```

**Explanation of commands:**

We create a `depression` column which is the sum of items 3, 5, 10, 13, 16, 17 and 21. Item 1 is in column 5, so we add 4 to each one. We assign the result back to `dass21`.

We use similar commands to create `anxiety` and `stress` columns based on the items which make up these subscales.


<a name="cronbach"></a>

# Calculate Cronbach’s alpha

Cronbach's alpha is a measure of scale reliability based on the consistency of correlations between different groupings of the individual scale items. When a new scale is developed, it's reliability is normally reported using Cronbach's alpha. It's wise to ensure that the Cronbach's alpha for your sample is similar to this value.

We'll write a function to calculate alpha for the SSES using the `cronbach()` function from the `psy` package:

```{r cronbach}
library(psy)

sses_cronbach <- function(scores) {
  cronbach <- cronbach(select(scores, q1:q20))
  data.frame(cronbach$alpha)
}
```

**Explanation of commands:**

Our function `sses_cronbach` expects its `scores` argument to be a data frame containing SSES scores.

The `cronbach()` function expects a data frame with one row per subject, and columns containing the scale scores. We supply this using the function `select(scores, q1:q20)`. Notice how we can use the column names in `scores` to specify the range of columns to `select()`.

In addition to the value of alpha, `cronbach()` returns the number of subjects and the number of items. Here were only interested in alpha, which we return in a data frame. Returning alpha in a data frame will help us to use the function for calculating alpha by group.

We can now calculate an overall alpha for SSES by calling `sses_cronbach` with all of our SSES data, using `bind_rows(sses_pre, sses_post)`:

```{r cronbach-all}
sses_cronbach_total <- sses_cronbach(bind_rows(sses_pre, sses_post))
sses_cronbach_total
```

This gives us a value of `0.67`, which is quite a bit lower than the `0.92` reported by the authors who developed the scale (Heatherton & Polivy, 1991).

We can use the same function to calculate alpha for SSES baseline scores:

```{r cronbach-pre}
sses_pre_cronbach <- sses_pre %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_pre_cronbach
```

**Explanation of pipeline commands:**

We save the output of the pipeline in `sses_pre_cronbach`. We start by piping `sses_pre` into `group_by(condition)`.

We pipe this grouped data frame into `group_modify(~ sses_cronbach(.x))`. The `group_modify()` function allows you to run a function for each group in a grouped data frame. The `~` tells `group_modify()` to treat the next argument as a function, in this case `sses_cronbach(.x)`. The `.x` means the subset of rows created by our `group_by()`. The function used within `group_modify()` must return its result as a data frame. This explains why we returned alpha in a data frame in `sses_cronbach()`. So this code runs `sses_cronbach()` once for each set of rows that makes up our three conditions, with the three values of alpha combined into a single data frame.

You can see that `sses_pre_cronbach` has a `condition` column, and a column containing Cronbach's alpha for each condition.

We can use a similar pipeline to calculate post-interventiona alphas:

```{r cronbach-post}
sses_post_cronbach <- sses_post %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_post_cronbach
```

These data show that alpha is especially low in the `self` and `other` conditions.

<a name="baseline"></a>

# Compare baseline SSES scores between conditions

Now that we've calculated a total SSES score for each participant, we would like to check that there were no major differences between groups before our intervention. This should be the case if we successfully randomised participants to groups. If there are baseline differences we would need to account for these when comparing them to post-intervention scores. We can use a [within-subjects ANOVA](anova1.html#anovaWS) to compare the baseline SSES scores in our three groups.

```{r baseline}
library(BayesFactor, quietly = TRUE)
# FIXME: in base::try(expression, silent = silent) : not enough observations
bf <- anovaBF(formula = total ~ condition + subj, data = sses_pre, whichRandom = 'subj')
bf <- anovaBF(formula = total ~ condition, data = sses_pre)
bf
```

The Bayes factor of `0.68` is greater than the conventional `0.33` which would satisfy us that there were no differences between the groups. If we generate some descriptive statistics, we can see that the mean and standard deviation are slightly lower in the `other` group. We'll address this issue in the next section.

```{r baseline-descriptives}
sses_pre %>% group_by(condition) %>% summarise(mean = mean(total), sd = sd(total))
```

<a name="prepost"></a>

# Compare pre and post intervention SSES scores between conditions

The main question we'd like to answer is whether our two imagery interventions 
(visualising a negative mental image of oneself, or someone else) had effects on self esteem which differed from our control condition. We can test this using a [factorial ANOVA](anova3.html#bfact) to compare SSES scores before and after the three interventions. In this design, `condition` is a between-subjects variable, and `time` (pre and post intervention) is a repeated measure.

First we combine the pre and post data frames:

```{r prepost}
sses_pre_post <- bind_rows(sses_pre, sses_post) %>%
  mutate(time = factor(time))
```

Then we run our anova, including `subj` as a random factor:

```{r mixed-anova}
bf <- anovaBF(formula = total ~ time*condition + subj,
              data = sses_pre_post, whichRandom = 'subj')

```

Our Bayes factors indicate that there is a main effect of `condition`,

```{r condition}
bf[1]
```

no main effect of `time`,

```{r time}
bf[2]
```

and a `condition*time` interaction

```{r condition*time}
bf[4] / bf[3]
```

Given the interaction, we would probably want to carry out [pairwise comparisons](anova1.html#pairs) to compare the imagery conditions against the control condition, and against each other. Finally, to address the small difference in baseline scores, we could run the same ANOVA on the _difference_ between the pre and post scores, or we could include the baseline score as a covariate in an ANCOVA.  These techniques are outside the scope of this worksheet.

# References

Heatherton, T. F., & Polivy, J. (1991). Development and validation of a scale for measuring state self-esteem. _Journal of Personality and Social Psychology, 60(6)_, 895.

Osman, A., Wong, J. L., Bagge, C. L., Freedenthal, S., Gutierrez, P. M., & Lozano, G. (2012). The Depression Anxiety Stress Scales—21 (DASS-21): Further Examination of Dimensions, Scale Reliability, and Correlates. _Journal of Clinical Psychology, 68(12)_, 1322–1338. https://doi.org/10.1002/jclp.21908

___

This material is distributed under a [Creative Commons](https://creativecommons.org/) licence. CC-BY-SA 4.0. 

