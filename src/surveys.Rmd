---
title: "Analysing survey data"
author: "Paul Sharpe, Sophie Homer"
output: html_document
---

```{r setup, include=FALSE}
## DEVELOPERS: Uncomment one option, as appropriate

## Show only commands.
## knitr::opts_chunk$set(echo = TRUE, message = FALSE, results='hide', fig.keep = 'none', comment=NA)

## Show commands and putout.
knitr::opts_chunk$set(echo = TRUE, comment=NA, cache = TRUE)
```

# Contents

- [Introduction](#intro)

- [Getting started](#start)

- [Reverse score some survey items](#reverse)

- [Calculate a total score for pre and post](#score)

- [Calculate cronbach’s alpha](#cronbach)

- [Compare baseline SSES scores between conditions using a one-way ANOVA (hoping not to find differences at baseline)](#baseline)

- [Run a within-between ANOVA with time as the repeated measures factor and condition as the between-subjects factor](#prepost)

<a name="intro"></a>

# Introduction

In this worksheet, we'll analyse data from a survey called the State Self-Esteem Scale (SSES). The SSES consists of 20 questions, each of which is scored from 0 (Not at all) to 4 (Extremely). 

<a name="start"></a>

# Getting started

Create a new R project and upload the files `dass21.csv` and `state-self-esteem.sav`, which you will find in the git repository we used [previously](preproc.html#load).

FIXME <span style="color: red;">Add data sets to rminr-data</span>

```{r init-load, message=FALSE}
## Clear the environment
rm(list = ls())
library(tidyverse)
```

## Pre-processing

```{r pre-process-dass}
dass21_raw <- read_csv("dass21.csv") %>%
  select(partID, Age:DASSS)
```

### Missing data

```{r missing}
slice(dass21_raw, 73:76)
dass21 <- dass21_raw %>% drop_na()
```

For the remainder of the worksheet, we'll be using data from an experiment which explored mental imagery and self-esteem. This data was saved from SPSS. R can read SPSS `.sav` files into a data frame using the `read.spss()` function from the `foreign` package.

```{r read-sses}
library(foreign)
sses <- read.spss(paste0('state-self-esteem.sav'), to.data.frame=TRUE)
```

```{r pre-process-sses}
sses_pre_raw  <- sses %>% select(1, 5:25) %>%
    set_names(~ str_to_lower(.) %>%
                  str_replace_all("pre_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('pre')) %>%
  select(subj, condition, time, q1:q20)
sses_pre_raw$condition <- recode_factor(sses_pre_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

sses_post_raw <- sses %>% select(1, 25:45) %>%
      set_names(~ str_to_lower(.) %>%
                  str_replace_all("post_sse_", "q")) %>%
  mutate(subj = factor(partid), condition = factor(condition), time = factor('post')) %>%
  select(subj, condition, time, q1:q20)
sses_post_raw$condition <- recode_factor(sses_post_raw$condition, `0` = 'control',
                                        `1` = 'self', `2` = 'other')

```

<a name="reverse"></a>

# Reverse score survey

Explain reverse coding.

Some surveys have some reverse coded items because...

```{r reverse}
# Reverse score survey items
# @param scores raw scores
# @param reverse character vector of columns to be reverse scored
# @param max integer value of maximum score
reverse_score_survey <- function(scores, reverse, max) {
  reverse_score <- function(score) { max - score } # for scores which start at 0, for starting at 1, max + 1 - score
  scores %>% mutate_at(reverse, reverse_score)
}

reverse_questions <- c('q2', 'q4', 'q5', 'q7', 'q8', 'q10', 'q13', 'q15', 'q16', 'q17', 'q18',
                       'q19', 'q20')
sses_pre <- sses_pre_raw %>%
  group_by(condition) %>%
  group_modify(~ reverse_score_survey(.x, reverse_questions, 4)) %>%
  ungroup()
sses_post <- sses_post_raw %>%
  group_by(condition) %>%
  group_modify(~ reverse_score_survey(.x, reverse_questions, 4)) %>%
  ungroup()
```

<a name="score"></a>

# Calculate a total score for pre and post

```{r score}
sses_pre <- sses_pre %>% mutate(total = rowSums(.[4:23]))
sses_pre %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))

sses_post <- sses_post %>% mutate(total = rowSums(.[4:23]))
sses_post %>%
  group_by(condition) %>%
  summarise(mean = mean(total), sd = sd(total))
```

<a name="cronbach"></a>

# Calculate Cronbach’s alpha

```{r cronbach}
library(psy)
sses_cronbach <- function(scores) {
  cronbach <- cronbach(select(scores,q1:q20))
  data.frame(cronbach$alpha)
}

sses_pre_cronbach <- sses_pre %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_pre_cronbach

sses_post_cronbach <- sses_post %>%
  group_by(condition) %>%
  group_modify(~ sses_cronbach(.x))
sses_post_cronbach
```

<a name="baseline"></a>

# Compare baseline SSES scores between conditions

* one-way ANOVA
* hope not to find differences

```{r baseline}
library(BayesFactor, quietly = TRUE)
# FIXME: in base::try(expression, silent = silent) : not enough observations
bf <- anovaBF(formula = total ~ condition + subj, data = sses_pre, whichRandom = 'subj')
bf <- anovaBF(formula = total ~ condition, data = sses_pre)
bf
```

<a name="prepost"></a>

# Pre-post

* Within-between ANOVA sses ~ time*condition
* time is the repeated measures factor
* condition is the between-subjects factor

```{r prepost}

# FIXME: Is there a better way to combine time avoiding 'Unequal factor levels: ... ' warning
sses_pre_post <- bind_rows(sses_pre, sses_post) %>%
  mutate(time = factor(time))

bf <- anovaBF(formula = total ~ time*condition + subj,
              data = sses_pre_post, whichRandom = 'subj')

bf
bf[1]         # condition
bf[2]         # time
bf[4] / bf[3] # condition * time
```

* TODO <span style="color: red;">Given that there's an interaction, how much should we say about [pairwise comparisons](https://ajwills72.github.io/rminr/anova1.html#pairs)?</span>

___

This material is distributed under a [Creative Commons](https://creativecommons.org/) licence. CC-BY-SA 4.0. 

